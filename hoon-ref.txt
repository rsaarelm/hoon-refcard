           HOON REFERENCE CARD
                  2015

bar: Core construction

|%  ++  p1  P1  generic core with
    +-  p2  P2  dry or wet arms
    ...
    --
|_  p           door with sample
    ++  q1  Q1  dry arms only
    ...
    --
|/  p           door with tile
    +-  q1  Q1  wet arms
    ...
    --
|^  p           kicked book
    ++  q1  Q1  like |- with arms
    ...
    --
|=(p q)     dry gate, arm is $
|+(p q)     dry gate, sample p is private
|*(p q)     wet gate, arm is $
|.(p)       generic dry trap (thunk)
|-(p)       kick after construction (loop)
|?(p)       dry trap, payload is hidden


buc: Tile construction

?(p q)     ($?) produce a fern fork
$|(p q)         produce a reed of tiles p, q
$&(p q)         produce a bush
[p q]      ($:) construct tile of a tuple
_p         ($_) produce a weed
$=(p q)         produce a bark, face to noun
*p         ($*) produce default value of p
,p         ($,) a normalizing gate, leaf
$^(p)           a normalizing gate, herb
$+(p q)         gate from p to q signature
p@q        ($@) whip wing p into tile q


cen: Pulling arms and wings

p(q1 Q1, ...)  (%=) eval p with changes
%_(p q1 Q1, ...)    eval with changes, cast
                    product to type of p
%*(p q r1 R1, ...)  pull p from q, eval with
                    changes
(p q)      (%-) call p with arguments q
%.(p q)         call q with arguments p
~(p q r)   (%~) pull p from q with sample r
%:(p q)         slam p with one argument
%+(p q r)       slam p with two arguments
%^(p q r s)     slam p with three arguments


col: Tuple construction

:-(p q)         tuple of two elements
:_(q p)         build reversed tuple [q p]
:+(p q r)       tuple of three elements
:^(p q r s)     tuple of four elements
[p1 ...]   (:*) arbitrary length tuple
~[p1 ...]  (:~) null-terminated tuple
:/(p)           tuple for interpolation


dot: Nock operators

+(p)       (.+) increment p
=(p q)     (.=) test p and q for equality
.^(p)           load file in userspace Nock
.*(p q)         Nock formula q on subject p


hax: Pretty printing

<p1 ...>   (#<) prettyprint into a tape
>p1 ...<   (#>) prettyprint into a tank


ket: Type operations

`p`q       (^-) cast q to bunt p
^+(p q)         cast q to type of p
p=q        (^=) wrap q in toga p
^|(p)           convert gold core to iron
^&(p)           convert gold core to zinc
^?(p)           convert gold core to lead
^.(p q)         cast q to type of (p q)
^~(p)           compile time execute p


sem: Composition

:(p q1 ...) (;:) fold over q with gate p
;~(p q1 ...)     compose gates under monad
;;(p q)          assert q as fixpoint of p
"p"         (;") construct a string
-{p}        (;-) interpolate a tape
+{p}        (;+) interpolate a manx
*{p}        (;*) interpolate a list of marl
%{p}        (;%) pass child nodes to gate


sig: Hints to interpreter

~$(p q)         label q as p for profiling
~|(p q)         log p in stack trace of q
~_(p q)         insert tank p in trace of q
~%  p  q  ==    jet hint for core s
  r1  s1  ...
  ==  t

~/(p q)         book arm jet
~+(p)           memoize computation p
~&(p q r)       print q at level p before r
                p is empty | > | >> | >>>
~=(p q)         product of q may equal noun p
~!(p q)         show type of p if q fails
~>(p q)         apply hint p to q
~<(p q)         compute q, then apply hint p


tis: Subject modification

=>(p q)         use p as subject of q
p:q        (=<) use q as subject of p
=+(p q)         push p in subject for q
=-(p q)         push q in subject for p
=|(p q)         push bunt of p in subject
=*(p q r)       alias p to q for r
=.(p q r)       set p to q in subject for r
=:  p1  P1      batch change subject for q
    ...
    ==  q
=^(p q r s)     state machine,
                update q with r, store in p
=~(p1 ...)      compose a list of twigs


wut: Conditionals

?:  p  q  r     q if p else r
?.  p  q  r     r if p else q
?-              switch for value of p
    ?-(p p1 q1, p2 q2, p3 q3)
?+              switch with default result q
    ?+(p q p1 q1, p2 q2, p3 q3)
?=  p  q        true if q is in tile p
?|  |(p1 p2 p3) "or" for loobeans in p
?&  &(p1 p2 p3) "and" for loobeans in p
?<  p  q        assert p is no, produce q
?>  p  q        assert p is yes, produce q
?^  p  q  r     r if p is p's bunt, else q
?@  p  q  r     q if p is atom, else r
?~  p  q  r     q if p is ~, else r
?!  !p          logical not of p


zap: Special operations

!_  !p          path / location trace
!.  p  q        insert q as p type constant
!/  p  q        report subject as error
!>  p           produce vase of p
!;  p  q        q as [type noun] pair, type p
!=  p           show Nock formula for p
!?  p           restrict Hoon version to p
!!              crash if evaluated
Pronunciation

ace  space         gap  newline or 2 spaces
bar  |   dot  .    ket  ^    ser  ]
bas  \   fas  /    lus  +    sig  ~
buc  $   gal  <    pam  &    soq  '
cab  _   gar  >    pat  @    tar  *
cen  %   hax  #    pel  (    tec  `
col  :   hep  -    per  )    tis  =
com  ,   kel  {    sel  [    wut  ?
doq  "   ker  }    sem  ;    zap  !

--  shed   ->  lark   +>  dark   ==  stet
++  slus   -<  lush   +<  dish


Odors

@c              UTF-32 codepoint
@d              date
  @da           absolute date
  @dr           relative date (ie, timespan)
@f              yes or no (inverse boolean)
@n              nil
@p              phonemic base
@r              IEEE floating-point
  @rd           double precision  (64 bits)
  @rh           half precision (16 bits)
  @rq           quad precision (128 bits)
  @rs           single precision (32 bits)
@s              signed integer, sign bit low
  @sb           signed binary
  @sd           signed decimal
  @sv           signed base32
  @sw           signed base64
  @sx           signed hexadecimal
@t              UTF-8 text (cord)
  @ta           ASCII text (span)
    @tas        ASCII symbol (term)
@u              unsigned integer
  @ub           unsigned binary
  @ud           unsigned decimal
  @uv           unsigned base32
  @uw           unsigned base64
  @ux           unsigned hexadecimal
Nock 5K

nock(a)             *a
[a b c]             [a [b c]]

?[a b]              0
?a                  1
+[a b]              +[a b]
+a                  1 + a
=[a a]              0
=[a b]              1
=a                  =a

/[1 a]              a
/[2 [a b]]          a
/[3 [a b]]          b
/[(a + a) b]        /[2 /[a b]]
/[(a + a + 1) b]    /[3 /[a b]]
/a                  /a

*[a [[b c] d]]      [*[a [b c]] *[a d]]

*[a [0 b]]          /[b a]
*[a [1 b]]          b
*[a [2 [b c]]]      *[*[a b] *[a c]]
*[a [3 b]]          ?*[a b]
*[a [4 b]]          +*[a b]
*[a [5 b]]          =*[a b]

*[a [6 [b [c d]]]]  *[a 2 [0 1] 2 [1 c d]
                      [1 0] 2 [1 2 3] [1 0]
                      4 4 b]
*[a [7 [b c]]]      *[a 2 b 1 c]
*[a [8 [b c]]]      *[a 7
                      [[7 [0 1] b] 0 1] c]
*[a [9 [b c]]]      *[a 7 c 2 [0 1] 0 b]
*[a [10 [[b c] d]]] *[a 8 c 7 [0 3] d]
*[a [10 [b c]]]     *[a c]

*a                  *a


http://urbit.org/

This document is public domain

= vim:textwidth=45:formatoptions+=t =========
