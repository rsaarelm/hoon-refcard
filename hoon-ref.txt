=============================================
           HOON REFERENCE CARD
                  2015

Pronunciation

ace  space         gap  newline or 2 spaces
bar  |   dot  .    ket  ^    ser  ]
bas  \   fas  /    lus  +    sig  ~
buc  $   gal  <    pam  &    soq  '
cab  _   gar  >    pat  @    tar  *
cen  %   hax  #    pel  (    tec  `
col  :   hep  -    per  )    tis  =
com  ,   kel  {    sel  [    wut  ?
doq  "   ker  }    sem  ;    zap  !

--  shed   ->  lark   +>  dark   ==  stet
++  slus   -<  lush   +<  dish


bar: Core construction

|%               generic core with arms
    ++  p.n.q    dry or wet arms
      q.n.q
    +-  p.n.l.q
      q.n.l.q
    --
|_  p            door with sample
    ++  p.n.q    dry arms only
      q.n.q
    --
|/  p            door with tile
    +-  p.n.q    wet arms
      q.n.q
    --
|^  p            kicked book
    ++  p.n.q    like |- with arms
      q.n.q
    --
|=  p  q    dry gate, arm is $
|+  p  q    dry gate, sample p is private
|*  p  q    wet gate, arm is $
|.  p       generic dry trap (thunk)
|-  p       kick after construction (loop)
|?  p       dry trap, payload is hidden
buc: Tile construction

$?  ?(p q)      produce a fern fork
$|  p  q        produce a reed of tiles p, q
$&  p  q        produce a bush
$:  [p q]       construct tile of a tuple
$_  _p          produce a weed
$=  p  q        produce a bark, face to noun
$*  *p          produce default value of p
$,  ,p          a normalizing gate, leaf
$^  p           a normalizing gate, herb
$+  p  q        gate from p to q signature
$@  p@q         whip wing p into tile q
$!              axil bunt (internal)


col: Tuple construction

:-  [p q]       tuple of two elements
:_  p  q        build reversed tuple [q p]
:+  p  q  r     tuple of three elements
:^  p  q        tuple of four elements
    r  s
:*  i.p         arbitrary length tuple
    i.t.p       [i.p i.t.p i.t.t.p]
    i.t.t.p
    ==
:~  i.p         null-terminated tuple
    i.t.p       ~[i.p i.t.p i.t.t.p]
    i.t.t.p
    ==
;/  p           tuple for interpolation


cen: Pulling arms and wings

%=  p           eval p with changes from q
    p1.q  q1.q  %=(p p1.q q1.q, p2.q q2.q)
    p2.q  q2.q  p(p1.q q1.q, p2.q q2.q)
    ==
%_  p           eval, then cast back to type
    p1.q  q1.q  %_(p p1.q q1.q, p2.q q2.q)
    p2.q  q2.q
    ==
%*  p  q        pull p from q with changes r
    p1.r  q1.r  %*(p q p1.r q1.r, p2.r q2.r)
    p2.r  q2.r
    ==
%-  (p q)       call p with arguments q
%.  p  q        %-(q p)
%~  ~(p q r)    call p with q with sample r
%:  p  q        slam p with one argument
%+  p  q  r     slam p with two arguments
%^  p  q  r  s  slam p with three arguments


dot: Nock operators

.+  +(p)    increment p
.=  =(p q)  test p and q for equality
.^  p       load file from global namespace
.*  p       execute Nock expression


hax: Pretty printing

#<  <i.p i.t.p i.t.t.p>  prettyprint a tape
#>  >i.p i.t.p i.t.t.p<  prettyprint a tank


ket: Type operations

^-  `p`q        cast q to bunt p
^+  p  q        cast q to type of p
^=  p=q         wrap q in toga p
^|  p           convert gold core to iron
^&  p           convert gold core to zinc
^?  p           convert gold core to lead
^.  p  q        cast q to type of (p q)
^~  p           compile time execute p


sig: Hints to interpreter

~$  p  q        label q as p for profiling
~|  p  q        log p in stack trace of q
~_  p  q        insert tank p in trace of q
~%  p  q  ~  s  jet hint for core s
~/  p  q        book arm jet
~+  p           memoize computation p
~&  p  q  r     print q at level p before r
~=  p  q        product of q may equal noun p
~!  p  q        show type of p if q fails
~>  p  q        apply hint p to q
~<  p  q        compute q, then apply hint p
sem: Composition

;:  p           fold over q tuple with gate p
    i.q         :(p i.q i.t.q i.t.t.q)
    i.t.q  i.t.t.q  ==
;~  p           compose gates under monad
    i.q
    i.t.q  i.t.t.q  ==
;;  p  q        assert q as fixpoint of p
;"  "p"         construct a string
;-  -{a}        interpolate a tape
;+  +{a}        interpolate a manx
;*  *{a}        interpolate a list of marl
;%  %{p}        pass child nodes to gate


tis: Subject modification

=>  p  q        use p as subject of q
=<  p:q         use q as subject of p
=+  p  q        push p in subject for q
=-  p  q        push q in subject for p
=|  p  q        push bunt of p in subject
=*  p  q  r     alias p to q for r
=.  p  q  r     set p to q in subject for r
=:  p.i.p  q.i.p  batch change subject for q
    p.i.t.p  q.i.t.p
    ==  q
=^  p  q  r  s  state machine,
                update q with r, store in p
=~  i.p         compose a list of twigs
    i.t.p  i.t.t.p  ==


wut: Conditionals

?:  p  q  r     q if p else r
?.  p  q  r     r if p else q
?-              switch for value of p
    ?-(p p1 q1, p2 q2, p3 q3)
?+              switch with default result q
    ?+(p q p1 q1, p2 q2, p3 q3)
?=  p  q        true if q is in tile p
?|  |(p1 p2 p3) "or" for loobeans in p
?&  &(p1 p2 p3) "and" for loobeans in p
?<  p  q        assert p is no, produce q
?>  p  q        assert p is yes, produce q
?^  p  q  r     r if p is p's bunt, else q
?@  p  q  r     q if p is atom, else r
?~  p  q  r     q if p is ~, else r
?!  !p          logical not of p


zap: Special operations

!_  !p          path / location trace
!.  p  q        insert q as p type constant
!/  p  q        report subject as error
!>  p           produce vase of p
!;  p  q        q as [type noun] pair, type p
!=  p           show Nock formula for p
!?  p           restrict Hoon version to p
!!              crash if evaluated

# vim:textwidth=45:formatoptions+=t
