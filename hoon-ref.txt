=============================================
           HOON REFERENCE CARD
                  2015

Pronunciation

ace  space         gap  newline or 2 spaces
bar  |   dot  .    ket  ^    ser  ]
bas  \   fas  /    lus  +    sig  ~
buc  $   gal  <    pam  &    soq  '
cab  _   gar  >    pat  @    tar  *
cen  %   hax  #    pel  (    tec  `
col  :   hep  -    per  )    tis  =
com  ,   kel  {    sel  [    wut  ?
doq  "   ker  }    sem  ;    zap  !

--  shed   ->  lark   +>  dark   ==  stet
++  slus   -<  lush   +<  dish


bar: Core construction

|%               generic core with arms
    ++  p.n.q    dry or wet arms
      q.n.q
    +-  p.n.l.q
      q.n.l.q
    --
|_  p            door with sample
    ++  p.n.q    dry arms only
      q.n.q
    --
|/  p            door with tile
    +-  p.n.q    wet arms
      q.n.q
    --
|^  p            kicked book
    ++  p.n.q    like |- with arms
      q.n.q
    --
|=  p  q    dry gate, arm is $
|+  p  q    dry gate, sample p is private
|*  p  q    wet gate, arm is $
|.  p       generic dry trap (thunk)
|-  p       kick after construction (loop)
|?  p       dry trap, payload is hidden
dot: Nock operators

.+  +(p)    increment p
.=  =(p q)  test p and q for equality
.^  p       load file from global namespace
.*  p       execute Nock expression


col: Tuple construction

:-  [p q]       tuple of two elements
:_  p  q        build reversed tuple [q p]
:+  p  q  r     tuple of three elements
:^  p  q        tuple of four elements
    r  s
:*  i.p         arbitrary length tuple
    i.t.p       [i.p i.t.p i.t.t.p]
    i.t.t.p
    ==
:~  i.p         null-terminated tuple
    i.t.p       ~[i.p i.t.p i.t.t.p]
    i.t.t.p
    ==
;/  p           tuple for interpolation


cen: Pulling arms and wings

%=  p           eval p with changes from q
    p1.q  q1.q  %=(p p1.q q1.q, p2.q q2.q)
    p2.q  q2.q  p(p1.q q1.q, p2.q q2.q)
    ==
%_  p           eval, then cast back to type
    p1.q  q1.q  %_(p p1.q q1.q, p2.q q2.q)
    p2.q  q2.q
    ==
%*  p  q        pull p from q with changes r
    p1.r  q1.r  %*(p q p1.r q1.r, p2.r q2.r)
    p2.r  q2.r
    ==
%-  (p q)       call p with arguments q
%.  p  q        %-(q p)
%~  ~(p q r)    call p with q with sample r
%:  p  q        slam p with one argument
%+  p  q  r     slam p with two arguments
%^  p  q  r  s  slam p with three arguments

%cnzy p         pull limb p from subject
%cnzz p         pull wing p from subject

ket: Type operations

^-  `p`q        cast q to bunt p
^+  p  q        cast q to type of p
^=  p=q         wrap q in toga p
^|  p           convert gold core to iron
^&  p           convert gold core to zinc
^?  p           convert gold core to lead
^.  p  q        cast q to type of (p q)
^~  p           compile time execute p

sig: Hints to interpreter

~$  p  q        label q as p for profiling
~|  p  q        log p in stack trace of q
~_  p  q        insert tank p in trace of q
~%  p  q  ~  s  jet hint for core s
~/  p  q        book arm jet
~+  p           memoize computation p
~&  p  q  r     print q at level p before r
~=  p  q        product of q may equal noun p
~!  p  q        show type of p if q fails
~>  p  q        apply hint p to q
~<  p  q        compute q, then apply hint p

hax: Pretty printing

#<  <i.p i.t.p i.t.t.p>  prettyprint a tape
#>  >i.p i.t.p i.t.t.p<  prettyprint a tank

# vim:textwidth=45:formatoptions+=t
